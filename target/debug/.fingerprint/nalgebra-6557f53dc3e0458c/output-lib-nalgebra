{"message":"use of unstable library feature 'ptr_offset_from'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using rustup).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/dallinhagman/.cargo/registry/src/github.com-1ecc6299db9ec823/nalgebra-0.25.3/src/base/iter.rs","byte_start":5528,"byte_end":5539,"line_start":134,"line_end":134,"column_start":61,"column_end":72,"is_primary":true,"text":[{"text":"                        let inner_raw_size = self.inner_end.offset_from(self.inner_ptr) as usize;","highlight_start":61,"highlight_end":72}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/dallinhagman/.cargo/registry/src/github.com-1ecc6299db9ec823/nalgebra-0.25.3/src/base/iter.rs","byte_start":6770,"byte_end":6841,"line_start":171,"line_end":171,"column_start":1,"column_end":72,"is_primary":false,"text":[{"text":"iterator!(struct MatrixIter for Storage.ptr -> *const N, &'a N, &'a S);","highlight_start":1,"highlight_end":72}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"iterator!","def_site_span":{"file_name":"/Users/dallinhagman/.cargo/registry/src/github.com-1ecc6299db9ec823/nalgebra-0.25.3/src/base/iter.rs","byte_start":251,"byte_end":6768,"line_start":11,"line_end":169,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! iterator {","highlight_start":1,"highlight_end":24},{"text":"    (struct $Name:ident for $Storage:ident.$ptr: ident -> $Ptr:ty, $Ref:ty, $SRef: ty) => {","highlight_start":1,"highlight_end":92},{"text":"        /// An iterator through a dense matrix with arbitrary strides matrix.","highlight_start":1,"highlight_end":78},{"text":"        pub struct $Name<'a, N: Scalar, R: Dim, C: Dim, S: 'a + $Storage<N, R, C>> {","highlight_start":1,"highlight_end":85},{"text":"            ptr: $Ptr,","highlight_start":1,"highlight_end":23},{"text":"            inner_ptr: $Ptr,","highlight_start":1,"highlight_end":29},{"text":"            inner_end: $Ptr,","highlight_start":1,"highlight_end":29},{"text":"            size: usize, // We can't use an end pointer here because a stride might be zero.","highlight_start":1,"highlight_end":93},{"text":"            strides: (S::RStride, S::CStride),","highlight_start":1,"highlight_end":47},{"text":"            _phantoms: PhantomData<($Ref, R, C, S)>,","highlight_start":1,"highlight_end":53},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // TODO: we need to specialize for the case where the matrix storage is owned (in which","highlight_start":1,"highlight_end":96},{"text":"        // case the iterator is trivial because it does not have any stride).","highlight_start":1,"highlight_end":78},{"text":"        impl<'a, N: Scalar, R: Dim, C: Dim, S: 'a + $Storage<N, R, C>> $Name<'a, N, R, C, S> {","highlight_start":1,"highlight_end":95},{"text":"            /// Creates a new iterator for the given matrix storage.","highlight_start":1,"highlight_end":69},{"text":"            pub fn new(storage: $SRef) -> $Name<'a, N, R, C, S> {","highlight_start":1,"highlight_end":66},{"text":"                let shape = storage.shape();","highlight_start":1,"highlight_end":45},{"text":"                let strides = storage.strides();","highlight_start":1,"highlight_end":49},{"text":"                let inner_offset = shape.0.value() * strides.0.value();","highlight_start":1,"highlight_end":72},{"text":"                let size = shape.0.value() * shape.1.value();","highlight_start":1,"highlight_end":62},{"text":"                let ptr = storage.$ptr();","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // If we have a size of 0, 'ptr' must be","highlight_start":1,"highlight_end":57},{"text":"                // dangling. Howver, 'inner_offset' might","highlight_start":1,"highlight_end":58},{"text":"                // not be zero if only one dimension is zero, so","highlight_start":1,"highlight_end":65},{"text":"                // we don't want to call 'offset'.","highlight_start":1,"highlight_end":51},{"text":"                // This pointer will never actually get used","highlight_start":1,"highlight_end":61},{"text":"                // if our size is '0', so it's fine to use","highlight_start":1,"highlight_end":59},{"text":"                // 'ptr' for both the start and end.","highlight_start":1,"highlight_end":53},{"text":"                let inner_end = if size == 0 {","highlight_start":1,"highlight_end":47},{"text":"                    ptr","highlight_start":1,"highlight_end":24},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // Safety:","highlight_start":1,"highlight_end":31},{"text":"                    // If 'size' is non-zero, we know that 'ptr'","highlight_start":1,"highlight_end":65},{"text":"                    // is not dangling, and 'inner_offset' must lie","highlight_start":1,"highlight_end":68},{"text":"                    // within the allocation","highlight_start":1,"highlight_end":45},{"text":"                    unsafe { ptr.add(inner_offset) }","highlight_start":1,"highlight_end":53},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                $Name {","highlight_start":1,"highlight_end":24},{"text":"                    ptr,","highlight_start":1,"highlight_end":25},{"text":"                    inner_ptr: ptr,","highlight_start":1,"highlight_end":36},{"text":"                    inner_end,","highlight_start":1,"highlight_end":31},{"text":"                    size: shape.0.value() * shape.1.value(),","highlight_start":1,"highlight_end":61},{"text":"                    strides,","highlight_start":1,"highlight_end":29},{"text":"                    _phantoms: PhantomData,","highlight_start":1,"highlight_end":44},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<'a, N: Scalar, R: Dim, C: Dim, S: 'a + $Storage<N, R, C>> Iterator","highlight_start":1,"highlight_end":80},{"text":"            for $Name<'a, N, R, C, S>","highlight_start":1,"highlight_end":38},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            type Item = $Ref;","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn next(&mut self) -> Option<$Ref> {","highlight_start":1,"highlight_end":49},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if self.size == 0 {","highlight_start":1,"highlight_end":40},{"text":"                        None","highlight_start":1,"highlight_end":29},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        self.size -= 1;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Jump to the next outer dimension if needed.","highlight_start":1,"highlight_end":71},{"text":"                        if self.ptr == self.inner_end {","highlight_start":1,"highlight_end":56},{"text":"                            let stride = self.strides.1.value() as isize;","highlight_start":1,"highlight_end":74},{"text":"                            // This might go past the end of the allocation,","highlight_start":1,"highlight_end":77},{"text":"                            // depending on the value of 'size'. We use","highlight_start":1,"highlight_end":72},{"text":"                            // `wrapping_offset` to avoid UB","highlight_start":1,"highlight_end":61},{"text":"                            self.inner_end = self.ptr.wrapping_offset(stride);","highlight_start":1,"highlight_end":79},{"text":"                            // This will always be in bounds, since","highlight_start":1,"highlight_end":68},{"text":"                            // we're going to dereference it","highlight_start":1,"highlight_end":61},{"text":"                            self.ptr = self.inner_ptr.offset(stride);","highlight_start":1,"highlight_end":70},{"text":"                            self.inner_ptr = self.ptr;","highlight_start":1,"highlight_end":55},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Go to the next element.","highlight_start":1,"highlight_end":51},{"text":"                        let old = self.ptr;","highlight_start":1,"highlight_end":44},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Don't offset `self.ptr` for the last element,","highlight_start":1,"highlight_end":73},{"text":"                        // as this will be out of bounds. Iteration is done","highlight_start":1,"highlight_end":76},{"text":"                        // at this point (the next call to `next` will return `None`)","highlight_start":1,"highlight_end":86},{"text":"                        // so this is not observable.","highlight_start":1,"highlight_end":54},{"text":"                        if self.size != 0 {","highlight_start":1,"highlight_end":44},{"text":"                            let stride = self.strides.0.value();","highlight_start":1,"highlight_end":65},{"text":"                            self.ptr = self.ptr.add(stride);","highlight_start":1,"highlight_end":61},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        Some(mem::transmute(old))","highlight_start":1,"highlight_end":50},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn size_hint(&self) -> (usize, Option<usize>) {","highlight_start":1,"highlight_end":60},{"text":"                (self.size, Some(self.size))","highlight_start":1,"highlight_end":45},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn count(self) -> usize {","highlight_start":1,"highlight_end":38},{"text":"                self.size_hint().0","highlight_start":1,"highlight_end":35},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<'a, N: Scalar, R: Dim, C: Dim, S: 'a + $Storage<N, R, C>> DoubleEndedIterator","highlight_start":1,"highlight_end":91},{"text":"            for $Name<'a, N, R, C, S>","highlight_start":1,"highlight_end":38},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn next_back(&mut self) -> Option<$Ref> {","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if self.size == 0 {","highlight_start":1,"highlight_end":40},{"text":"                        None","highlight_start":1,"highlight_end":29},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        // Pre-decrement `size` such that it now counts to the","highlight_start":1,"highlight_end":79},{"text":"                        // element we want to return.","highlight_start":1,"highlight_end":54},{"text":"                        self.size -= 1;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Fetch strides","highlight_start":1,"highlight_end":41},{"text":"                        let inner_stride = self.strides.0.value();","highlight_start":1,"highlight_end":67},{"text":"                        let outer_stride = self.strides.1.value();","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Compute number of rows","highlight_start":1,"highlight_end":50},{"text":"                        // Division should be exact","highlight_start":1,"highlight_end":52},{"text":"                        let inner_raw_size = self.inner_end.offset_from(self.inner_ptr) as usize;","highlight_start":1,"highlight_end":98},{"text":"                        let inner_size = inner_raw_size / inner_stride;","highlight_start":1,"highlight_end":72},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Compute rows and cols remaining","highlight_start":1,"highlight_end":59},{"text":"                        let outer_remaining = self.size / inner_size;","highlight_start":1,"highlight_end":70},{"text":"                        let inner_remaining = self.size % inner_size;","highlight_start":1,"highlight_end":70},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Compute pointer to last element","highlight_start":1,"highlight_end":59},{"text":"                        let last = self.ptr.offset(","highlight_start":1,"highlight_end":52},{"text":"                            (outer_remaining * outer_stride + inner_remaining * inner_stride)","highlight_start":1,"highlight_end":94},{"text":"                                as isize,","highlight_start":1,"highlight_end":42},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // We want either `& *last` or `&mut *last` here, depending","highlight_start":1,"highlight_end":84},{"text":"                        // on the mutability of `$Ref`.","highlight_start":1,"highlight_end":56},{"text":"                        Some(mem::transmute(last))","highlight_start":1,"highlight_end":51},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<'a, N: Scalar, R: Dim, C: Dim, S: 'a + $Storage<N, R, C>> ExactSizeIterator","highlight_start":1,"highlight_end":89},{"text":"            for $Name<'a, N, R, C, S>","highlight_start":1,"highlight_end":38},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn len(&self) -> usize {","highlight_start":1,"highlight_end":37},{"text":"                self.size","highlight_start":1,"highlight_end":26},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<'a, N: Scalar, R: Dim, C: Dim, S: 'a + $Storage<N, R, C>> FusedIterator","highlight_start":1,"highlight_end":85},{"text":"            for $Name<'a, N, R, C, S>","highlight_start":1,"highlight_end":38},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #41079 <https://github.com/rust-lang/rust/issues/41079> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'ptr_offset_from'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/dallinhagman/.cargo/registry/src/github.com-1ecc6299db9ec823/nalgebra-0.25.3/src/base/iter.rs:134:61\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m134\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        let inner_raw_size = self.inner_end.offset_from(self.inner_ptr) as usize;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m171\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0miterator!(struct MatrixIter for Storage.ptr -> *const N, &'a N, &'a S);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #41079 <https://github.com/rust-lang/rust/issues/41079> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"use of unstable library feature 'ptr_offset_from'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using rustup).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/dallinhagman/.cargo/registry/src/github.com-1ecc6299db9ec823/nalgebra-0.25.3/src/base/iter.rs","byte_start":5528,"byte_end":5539,"line_start":134,"line_end":134,"column_start":61,"column_end":72,"is_primary":true,"text":[{"text":"                        let inner_raw_size = self.inner_end.offset_from(self.inner_ptr) as usize;","highlight_start":61,"highlight_end":72}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/dallinhagman/.cargo/registry/src/github.com-1ecc6299db9ec823/nalgebra-0.25.3/src/base/iter.rs","byte_start":6842,"byte_end":6929,"line_start":172,"line_end":172,"column_start":1,"column_end":88,"is_primary":false,"text":[{"text":"iterator!(struct MatrixIterMut for StorageMut.ptr_mut -> *mut N, &'a mut N, &'a mut S);","highlight_start":1,"highlight_end":88}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"iterator!","def_site_span":{"file_name":"/Users/dallinhagman/.cargo/registry/src/github.com-1ecc6299db9ec823/nalgebra-0.25.3/src/base/iter.rs","byte_start":251,"byte_end":6768,"line_start":11,"line_end":169,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! iterator {","highlight_start":1,"highlight_end":24},{"text":"    (struct $Name:ident for $Storage:ident.$ptr: ident -> $Ptr:ty, $Ref:ty, $SRef: ty) => {","highlight_start":1,"highlight_end":92},{"text":"        /// An iterator through a dense matrix with arbitrary strides matrix.","highlight_start":1,"highlight_end":78},{"text":"        pub struct $Name<'a, N: Scalar, R: Dim, C: Dim, S: 'a + $Storage<N, R, C>> {","highlight_start":1,"highlight_end":85},{"text":"            ptr: $Ptr,","highlight_start":1,"highlight_end":23},{"text":"            inner_ptr: $Ptr,","highlight_start":1,"highlight_end":29},{"text":"            inner_end: $Ptr,","highlight_start":1,"highlight_end":29},{"text":"            size: usize, // We can't use an end pointer here because a stride might be zero.","highlight_start":1,"highlight_end":93},{"text":"            strides: (S::RStride, S::CStride),","highlight_start":1,"highlight_end":47},{"text":"            _phantoms: PhantomData<($Ref, R, C, S)>,","highlight_start":1,"highlight_end":53},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // TODO: we need to specialize for the case where the matrix storage is owned (in which","highlight_start":1,"highlight_end":96},{"text":"        // case the iterator is trivial because it does not have any stride).","highlight_start":1,"highlight_end":78},{"text":"        impl<'a, N: Scalar, R: Dim, C: Dim, S: 'a + $Storage<N, R, C>> $Name<'a, N, R, C, S> {","highlight_start":1,"highlight_end":95},{"text":"            /// Creates a new iterator for the given matrix storage.","highlight_start":1,"highlight_end":69},{"text":"            pub fn new(storage: $SRef) -> $Name<'a, N, R, C, S> {","highlight_start":1,"highlight_end":66},{"text":"                let shape = storage.shape();","highlight_start":1,"highlight_end":45},{"text":"                let strides = storage.strides();","highlight_start":1,"highlight_end":49},{"text":"                let inner_offset = shape.0.value() * strides.0.value();","highlight_start":1,"highlight_end":72},{"text":"                let size = shape.0.value() * shape.1.value();","highlight_start":1,"highlight_end":62},{"text":"                let ptr = storage.$ptr();","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // If we have a size of 0, 'ptr' must be","highlight_start":1,"highlight_end":57},{"text":"                // dangling. Howver, 'inner_offset' might","highlight_start":1,"highlight_end":58},{"text":"                // not be zero if only one dimension is zero, so","highlight_start":1,"highlight_end":65},{"text":"                // we don't want to call 'offset'.","highlight_start":1,"highlight_end":51},{"text":"                // This pointer will never actually get used","highlight_start":1,"highlight_end":61},{"text":"                // if our size is '0', so it's fine to use","highlight_start":1,"highlight_end":59},{"text":"                // 'ptr' for both the start and end.","highlight_start":1,"highlight_end":53},{"text":"                let inner_end = if size == 0 {","highlight_start":1,"highlight_end":47},{"text":"                    ptr","highlight_start":1,"highlight_end":24},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // Safety:","highlight_start":1,"highlight_end":31},{"text":"                    // If 'size' is non-zero, we know that 'ptr'","highlight_start":1,"highlight_end":65},{"text":"                    // is not dangling, and 'inner_offset' must lie","highlight_start":1,"highlight_end":68},{"text":"                    // within the allocation","highlight_start":1,"highlight_end":45},{"text":"                    unsafe { ptr.add(inner_offset) }","highlight_start":1,"highlight_end":53},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                $Name {","highlight_start":1,"highlight_end":24},{"text":"                    ptr,","highlight_start":1,"highlight_end":25},{"text":"                    inner_ptr: ptr,","highlight_start":1,"highlight_end":36},{"text":"                    inner_end,","highlight_start":1,"highlight_end":31},{"text":"                    size: shape.0.value() * shape.1.value(),","highlight_start":1,"highlight_end":61},{"text":"                    strides,","highlight_start":1,"highlight_end":29},{"text":"                    _phantoms: PhantomData,","highlight_start":1,"highlight_end":44},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<'a, N: Scalar, R: Dim, C: Dim, S: 'a + $Storage<N, R, C>> Iterator","highlight_start":1,"highlight_end":80},{"text":"            for $Name<'a, N, R, C, S>","highlight_start":1,"highlight_end":38},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            type Item = $Ref;","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn next(&mut self) -> Option<$Ref> {","highlight_start":1,"highlight_end":49},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if self.size == 0 {","highlight_start":1,"highlight_end":40},{"text":"                        None","highlight_start":1,"highlight_end":29},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        self.size -= 1;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Jump to the next outer dimension if needed.","highlight_start":1,"highlight_end":71},{"text":"                        if self.ptr == self.inner_end {","highlight_start":1,"highlight_end":56},{"text":"                            let stride = self.strides.1.value() as isize;","highlight_start":1,"highlight_end":74},{"text":"                            // This might go past the end of the allocation,","highlight_start":1,"highlight_end":77},{"text":"                            // depending on the value of 'size'. We use","highlight_start":1,"highlight_end":72},{"text":"                            // `wrapping_offset` to avoid UB","highlight_start":1,"highlight_end":61},{"text":"                            self.inner_end = self.ptr.wrapping_offset(stride);","highlight_start":1,"highlight_end":79},{"text":"                            // This will always be in bounds, since","highlight_start":1,"highlight_end":68},{"text":"                            // we're going to dereference it","highlight_start":1,"highlight_end":61},{"text":"                            self.ptr = self.inner_ptr.offset(stride);","highlight_start":1,"highlight_end":70},{"text":"                            self.inner_ptr = self.ptr;","highlight_start":1,"highlight_end":55},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Go to the next element.","highlight_start":1,"highlight_end":51},{"text":"                        let old = self.ptr;","highlight_start":1,"highlight_end":44},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Don't offset `self.ptr` for the last element,","highlight_start":1,"highlight_end":73},{"text":"                        // as this will be out of bounds. Iteration is done","highlight_start":1,"highlight_end":76},{"text":"                        // at this point (the next call to `next` will return `None`)","highlight_start":1,"highlight_end":86},{"text":"                        // so this is not observable.","highlight_start":1,"highlight_end":54},{"text":"                        if self.size != 0 {","highlight_start":1,"highlight_end":44},{"text":"                            let stride = self.strides.0.value();","highlight_start":1,"highlight_end":65},{"text":"                            self.ptr = self.ptr.add(stride);","highlight_start":1,"highlight_end":61},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        Some(mem::transmute(old))","highlight_start":1,"highlight_end":50},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn size_hint(&self) -> (usize, Option<usize>) {","highlight_start":1,"highlight_end":60},{"text":"                (self.size, Some(self.size))","highlight_start":1,"highlight_end":45},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn count(self) -> usize {","highlight_start":1,"highlight_end":38},{"text":"                self.size_hint().0","highlight_start":1,"highlight_end":35},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<'a, N: Scalar, R: Dim, C: Dim, S: 'a + $Storage<N, R, C>> DoubleEndedIterator","highlight_start":1,"highlight_end":91},{"text":"            for $Name<'a, N, R, C, S>","highlight_start":1,"highlight_end":38},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn next_back(&mut self) -> Option<$Ref> {","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if self.size == 0 {","highlight_start":1,"highlight_end":40},{"text":"                        None","highlight_start":1,"highlight_end":29},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        // Pre-decrement `size` such that it now counts to the","highlight_start":1,"highlight_end":79},{"text":"                        // element we want to return.","highlight_start":1,"highlight_end":54},{"text":"                        self.size -= 1;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Fetch strides","highlight_start":1,"highlight_end":41},{"text":"                        let inner_stride = self.strides.0.value();","highlight_start":1,"highlight_end":67},{"text":"                        let outer_stride = self.strides.1.value();","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Compute number of rows","highlight_start":1,"highlight_end":50},{"text":"                        // Division should be exact","highlight_start":1,"highlight_end":52},{"text":"                        let inner_raw_size = self.inner_end.offset_from(self.inner_ptr) as usize;","highlight_start":1,"highlight_end":98},{"text":"                        let inner_size = inner_raw_size / inner_stride;","highlight_start":1,"highlight_end":72},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Compute rows and cols remaining","highlight_start":1,"highlight_end":59},{"text":"                        let outer_remaining = self.size / inner_size;","highlight_start":1,"highlight_end":70},{"text":"                        let inner_remaining = self.size % inner_size;","highlight_start":1,"highlight_end":70},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // Compute pointer to last element","highlight_start":1,"highlight_end":59},{"text":"                        let last = self.ptr.offset(","highlight_start":1,"highlight_end":52},{"text":"                            (outer_remaining * outer_stride + inner_remaining * inner_stride)","highlight_start":1,"highlight_end":94},{"text":"                                as isize,","highlight_start":1,"highlight_end":42},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // We want either `& *last` or `&mut *last` here, depending","highlight_start":1,"highlight_end":84},{"text":"                        // on the mutability of `$Ref`.","highlight_start":1,"highlight_end":56},{"text":"                        Some(mem::transmute(last))","highlight_start":1,"highlight_end":51},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<'a, N: Scalar, R: Dim, C: Dim, S: 'a + $Storage<N, R, C>> ExactSizeIterator","highlight_start":1,"highlight_end":89},{"text":"            for $Name<'a, N, R, C, S>","highlight_start":1,"highlight_end":38},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn len(&self) -> usize {","highlight_start":1,"highlight_end":37},{"text":"                self.size","highlight_start":1,"highlight_end":26},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<'a, N: Scalar, R: Dim, C: Dim, S: 'a + $Storage<N, R, C>> FusedIterator","highlight_start":1,"highlight_end":85},{"text":"            for $Name<'a, N, R, C, S>","highlight_start":1,"highlight_end":38},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #41079 <https://github.com/rust-lang/rust/issues/41079> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'ptr_offset_from'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/dallinhagman/.cargo/registry/src/github.com-1ecc6299db9ec823/nalgebra-0.25.3/src/base/iter.rs:134:61\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m134\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        let inner_raw_size = self.inner_end.offset_from(self.inner_ptr) as usize;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0miterator!(struct MatrixIterMut for StorageMut.ptr_mut -> *mut N, &'a mut N, &'a mut S);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #41079 <https://github.com/rust-lang/rust/issues/41079> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"aborting due to 2 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 2 previous errors\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0658`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0658`.\u001b[0m\n"}
